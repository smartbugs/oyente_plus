# Update EVM & Solidity support

This file describes the changes made for Oyente to support the newest EVM and Solidity versions.

**Table of contents:**

- [Update EVM \& Solidity support](#update-evm--solidity-support)
  - [Disassembler](#disassembler)
    - [pyevmasm](#pyevmasm)
    - [evmdasm](#evmdasm)
    - [geas](#geas)
  - [Opcodes](#opcodes)
  - [Solidity](#solidity)
    - [New Abstract Syntax Tree (AST) format](#new-abstract-syntax-tree-ast-format)
    - [Source-Map](#source-map)
    - [Contract Metadata](#contract-metadata)
  - [Dockerfile](#dockerfile)
  - [Dependencies](#dependencies)
  - [Unittests](#unittests)

## Disassembler

The version before this update had a disassambler shipped with EVM `1.7.3` (evmasm), which is no longer shipped with the current EVM version (`1.15.11`). Therefore Oyente had to be updated to use different disassemblers.

You can now use `-d` as a parameter for an Oyente run, and decide which disassembler you want to use. The current choices are `pyevmasm`, `evmdasm` and `geas`. Each of these disassembles has their own methods of dealing with unknown opcodes and therefore we had to monkeypatch their output, to keep it consistent with Oyente's current functionality.

The function `_write_disasm_file` in `input_helper.py` deals with the output of each disassembler separatly. The format which Oyente expects - each seperated by a space - is:

| addess in 5 hex digits | opcode | stack values |
| ---------------------- | ------ | ------------ |
| 00001:                 | TSTORE | 0x0 0x1234   |

```bytecode
00001: TSTORE 0x0 0x1234
00002: PUSH0
...
```

### pyevmasm

With `pyevmasm` the index is not constructed for us, so we manually have to construct the addresses for each instruction. Therefore we iterate over the generated bytecode and increase the index by one for each instruction. If we have a PUSH instruction, the index is increased by 1 and the length of the data instead.

The main problem with `pyevmasm` is, that if the disassembler reaches an unknown opcode, we cannot monkeypatch the bytecode, because `pyevmasm` does not add the hexcode of the unknown opcode to the bytecode. It only writes `UNKNOWN`, which cannot be processed further by Oyente. We have to rely on the maintainers of the `pyemasm` repository to be up to date with current EVM opcodes.

Because an `UNKNOWN` opcode stops the symbolic execution at that point, we do not have a lot of code coverage with this disassembler.

### evmdasm

The current default disassembler for Oyente is `evmdasm`. We use it as default, because it is python based and therefore can easily be added via `setup-venv.py`. Even tough it is several years old and does not support the current opcodes of the EVM directly, it outputs unknown opcodes in a format we can later monkeypatch (e.g. `UNKNOWN_0xfe`). So we do not rely as heavy on the maintainers of the project as we do with other disassemblers. Even the index is constructed for us, so we only have to look for unknown opcodes in the generated bytecode and replace `UNKNOWN_0x..` with known opcodes.

### geas

`geas` writes invalid opcodes as `#bytes 0x$hex_value$`. This has to be monkeypatched for Oyente to work, so as with other disassemblers, we parse the generated bytecode and replace the unknown opcode strings with a format that is understandable by Oyente. `geas` is the newest disassembler in the mix and supports all the latest opcodes. But because it is based on GO, we are not setting it as the default disassembler, even tough we recommend it to be used.

## Opcodes

The opcodes and their respective costs were updated in `opcodes.py` and `symExec.py` was updated accordingly. To be able to better analyze what happens during symbolic execution in Oyente, a lot of debug logging was added during construction of vertices, edges and jump_types. In terms of the supported opcodes, the following changes were made:

- Added the following opcodes, their costs, their global_state variables (if necessary) and their symbolic execution:
  - `CHAINID`
  - `BASEFEE`
  - `BLOBHASH`
  - `BLOBBASEFEE`
  - `SELFBALANCE`
  - `MCOPY` (minimal implementation of the stack operations)
  - `PUSH0` (implemented as a special case of other PUSH operations)
  - `TLOAD` (loads from a global_state variable `It`, which does not get reset after a block was processed)
  - `TSTORE` (writes to a global_state variable `It`, which does not get reset after a block was processed)
- Renamed
  - `SUICIDE` to `SELFDESTRUCT`
  - `DIFFICULTY` to `PREVRANDAO`
  - `CALLSTATIC` to `REVERT`
  - `BREAKPOINT` to `CREATE2`
- Removed
  - `SLOADEXT`
  - `SSTOREEXT`
  - `SLOADBYTESEXT`
  - `SSTOREBYTESEXT`

For newly added opcodes with "complex" implementations (e.g. `MCOPY`, `TLOAD`, `TSTORE`) logging of the opcodes, when doing their symbolic exection was added to be able to enhance their modelling later, if necessary.

The current set of opcodes in `opcodes.py` is the set we are supporting - old opcodes will be mapped onto the new ones, if their hex value is the same, and the symbolic execution will be done based on the behavior of the new opcode (e.g. `SSTOREEXT` will be executed like `TSTORE`).

## Solidity

### New Abstract Syntax Tree (AST) format

Oyente’s symbolic executor walks the AST looking for `ContractDefinition`, `VariableDeclaration`, `FunctionCall`, etc., expecting the v4 shape (`node["name"]`, `node["children"]`, `node["attributes"]["..."]`). But since Solidity version `0.5.0+`, the AST format is nested and therefore Oyente could not correctly analyze Smart contracts with this Solidity version AST format.

We decided to detect which AST format we are facing and if its the v5+ AST format (Solidity version ≥ `0.5.0+`), we semi-convert it to the v4 AST format (Solidity version < `0.5.0+`), to avoid rewriting the entire symExec codebase. As newer Solidity versions introduce yet more AST changes, this method can be extended further or eventually be replaced by a refactored symExec, which natively understands the v5+ format.

The following table shows relevant differences between the old and the new format:

| Aspect                     | v4 format                                           | v5+ format                                                                                   |
|----------------------------|------------------------------------------------------|----------------------------------------------------------------------------------------------|
| **Root AST container**     | A flat JSON with `"AST"` at each source, listing a tree of nodes with keys: `name`, `attributes`, `children`, `id`, `src`. | A nested JSON where each node has `"nodeType"` and a `"nodes"` array; other fields (e.g. `parameters`, `returnParameters`, `body`) may also embed AST dicts inline. |
| **Node identity**          | Field `name` holds the node’s type (e.g. `"FunctionDefinition"`). | Field `nodeType` holds the node’s type; `name` may appear inside `attributes`.               |
| **Child nodes**            | Always under a `children` array, in the exact original Etherscan order. | Primarily under `nodes`, but may also appear inline under other keys (`parameters`, `body`, etc.). |
| **Attributes**             | Under an `attributes` object, containing only the data needed by symExec. | Spread across many fields: `typeDescriptions`, `stateMutability`, `mutability`, `nameLocation`, and so on. |
| **Type information**       | Synthesized into `attributes.type` by the compiler. | Encoded under `typeDescriptions.typeString` on type‐nodes (e.g. `ElementaryTypeName`).        |
| **Other metadata**         | No `typeDescriptions`, no `nodeType`, no inline mutability fields. | Richer metadata (`typeDescriptions`, `documentation`, `stateMutability`, etc.) that v4 code doesn’t understand. |

### Source-Map

New EVM versions introduced new names for existing opcodes and added new ones. To fix related issues in the `mapping_non_push_instructions` function, we create an alias mapping of known aliases for opcodes and use this mapping to check if the instruction name matches the source-map name. This alias map is currently located in the function and could be moved to a more global place (e.g. opcodes.py). New aliases can be added for supporting further changes of the EVM opcodes in the future.

To support the new `PUSH0` instruction, we needed to patch the `mapping_push_instruction` function, because in Solidity version ≥ `0.6.0` the source-map's `"name":"PUSH"` entries switched, to always be the zero-byte pushes. Numbered pushes keep their `"name":"PUSHn"`  *without* a matching `value` field. The function hex-compared every push value, which we therefore had to change.

### Contract Metadata

For static analysis with Oyente, we do not need the [Contract metadata](https://docs.soliditylang.org/en/latest/metadata.html) or the [NatSpec Format](https://docs.soliditylang.org/en/latest/natspec-format.html) data. The Soidity compiler adds a **CBOR-encoded map** and a **two byte big-endian length** of that map to the contract:

```json
{
  "ipfs": "<metadata hash>",
  // If "bytecodeHash" was "bzzr1" in compiler settings not "ipfs" but "bzzr1"
  "bzzr1": "<metadata hash>",
  // Previous versions were using "bzzr0" instead of "bzzr1"
  "bzzr0": "<metadata hash>",
  // If any experimental features that affect code generation are used
  "experimental": true,
  "solc": "<compiler version>"
}
```

It could include more fields in the future. Therefore we had to patch the bytecode produced by `solc`, by removing the Contract metadata and NatSpec format data from it.

We also added the [ethutils](https://github.com/gsalzer/ethutils)-Repository to zero all metadata still left in the contract, so Oyente has clean bytecode for further analysis.

## Dockerfile

The Dockerfile for Oyente was reworked completly. All Dockerfile linter warnings were fixed and a cleanup of the dependencies and statements was done. The base image is now `ubuntu:jammy`. Since `solc-select` does not work inside the container, the solidity version which is to be used, has to be set in the Dockerfile via `ARG SOLC_VERSION=x.x.x`. The version then gets installed automatically and the respective environment variable, which is used by solc, is set.

To be able to use the disassembler `geas`, we had to install go as a dependency.

## Dependencies

The dependencies were reviewed and we added the new disassemblers `evmdasm` and `pyevmasm` to the list. We also had some updates done:

- `crytic-compile` was updated to version `0.3.8`, which solved some minor issues with `solc` and `solc-select`
- `z3-solver` was updated to version `4.14.1.0`, which significantly improved performance of symbolic execution and fixed some minor issues as well

For removing the cbor metadata, we installed `cbor2` as a dependency.

## Unittests

Oyente has a set of unittests to test the EVM and some of the opcodes. This is done with `run_tests.py` which relys on test data stored in `test_evm/test_data` in json format. To add new tests, simply add new files with tests using the current format (or add the tests to the current files). Before our update `run_tests.py` and `test_evm/*.py` were written in `python2`, and are now updated to `python3`. During the upgrade some minor improvements were made to `test_evm/evm_unit_test.py` - now the subprocess library is used to run Oyente against the testfiles instead of the `os.system` function.
